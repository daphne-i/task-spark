import 'dart:io';

import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'package:task_sparkle/database/tables.dart'; // Import our tables
import 'package:drift/drift.dart' as drift;

// These 'part' files don't exist yet. Drift will create them for us.
part 'database.g.dart'; // Generated by drift

@DriftDatabase(tables: [Tasks, Categories])
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 1;

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (Migrator m) async {
        // This tells drift to create all the tables we defined
        await m.createAll();
        // --- ADD THIS CODE ---
        // After creating tables, let's insert default categories
        // We use 'batch' to do multiple inserts at once
        await batch((b) {
          b.insertAll(categories, [
            CategoriesCompanion.insert(name: 'Work'),
            CategoriesCompanion.insert(name: 'Home'),
            CategoriesCompanion.insert(name: 'Shopping'),
            CategoriesCompanion.insert(name: 'Personal'),
          ]);
        });
      },
    );
  }

  // --- Database Methods (we'll add more later) ---

  // Example: Watch all tasks
  Stream<List<Task>> watchAllTasks() => select(tasks).watch();

  // Example: Add a task
  Future<int> addTask(TasksCompanion entry) {
    return into(tasks).insert(entry);
  }

  Future<List<Category>> getAllCategories() => select(categories).get();
  Future<void> updateTaskCompletion(int taskId, bool isCompleted) {
    return (update(tasks)..where((t) => t.id.equals(taskId))).write(
      TasksCompanion(isCompleted: drift.Value(isCompleted)),
    );
  }

  // Deletes a task from the database by its ID
  Future<void> deleteTaskById(int taskId) {
    return (delete(tasks)..where((t) => t.id.equals(taskId))).go();
  }

  Future<Task?> getTaskById(int taskId) {
    return (select(tasks)..where((t) => t.id.equals(taskId))).getSingleOrNull();
  }

  Future<void> updateTask(int taskId, TasksCompanion taskData) {
    return (update(tasks)..where((t) => t.id.equals(taskId))).write(taskData);
  }
}

LazyDatabase _openConnection() {
  // This is the correct, self-contained function
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();

    // We define 'file' directly
    final file = File(p.join(dbFolder.path, 'db.sqlite'));

    return NativeDatabase(file);
  });
}
